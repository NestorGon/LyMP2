
using gold.**

var alf

procedure main ( args : String [ ] ) begin
	var sc : java.util.Scanner ( System.$in )
	decoder := createDecoder ( )
	//deCoder:=createDecoder()

	//GAutomataFrame.show(coder)
	//GAutomataFrame.show(deCoder)
	//Utilities.testCodeDecode ( coder , decoder )
	Utilities.test(decoder)

end

function createDecoder ( ) : ITransducer begin
	alf := ( 'a' ‥ 'z' )
	A := alf ∪ { λ }
	B := ( 0 ‥ 2 ) × ( 0 ‥ 4 )
	C := (A × B) ∪ {⟨':',⟨1,0⟩⟩}
	D := A × A
	Q := D ∪ ( D × C ) ∪ { 'I' , "num" , "err" } 
	Σ := alf  ∪ {':'} ∪ { '#' } ∪ ( 'A' ‥ 'Z' ) ∪ ( '0' ‥ '4' )
	Σ´ := alf  ∪ {':'} ∪ {'$'}
	q₀ := 'I'
	F := {"num"}

	return GDeterministicTransducer ( Q , Σ , Σ´ , q₀ , F , δ , g , h )
end

function δ ( A , n ) begin
	
	//Inicializacion
	if A = 'I' and n ∉ alf then
		return "err"
	elseif A = 'I' then
		return ⟨ n , λ ⟩
	elseif A = "err" or A = "num" then
		return "err"
	end
end

function δ ( ⟨ A , B ⟩ , n ) begin
	if A = λ or (A ∉ alf and (A[0] = λ or A[1] = λ)) or ( B ∉ alf and |B| > 1 and B[0] = λ) then
		return "err"
	elseif A ∈ alf then
		if B ∈ alf and n = ':' then
			return ⟨ ⟨ A , B ⟩ , ⟨ ':' , ⟨ 1, 0 ⟩ ⟩ ⟩
		elseif B ∉ alf and n ∈ alf then
			return ⟨ A , n ⟩
		else
			return "err"
		end
	else 
		a := (B [1][0]+1) % 3
		b := B[1][1]
		//Si hay un final y antes hay un dos puntos en la mitad de la cadena
		if n = "num" and B[0] = ':' then
			return "err"
		//Si el valor es igual a el final termina
		elseif n = b then
			return "num"
		elseif a=0 and n∈alf then
			return ⟨ A , ⟨ n , ⟨ a , b ⟩ ⟩ ⟩
		elseif a=1 and n∉alf then
			return ⟨ A , ⟨ n , ⟨ a , ( b + 1 ) % 5 ⟩ ⟩ ⟩
		elseif a=2 and n∉alf then
			return ⟨ A , ⟨ n , ⟨ a , ( b + 1 ) % 5 ⟩ ⟩ ⟩
		elseif n='#' then		
			return ⟨ A , ⟨ n , ⟨ a , ( b + 1 ) % 5 ⟩ ⟩ ⟩
		elseif a=1 and B[0]== backToDown(n)then
			return "err"
		elseif a=2 and B[0]== toDown(n)then
			return "err"
		else
			return "err"
		end
	end
end

function h ( A , n ) begin
	if A = 'I' and n ∉ alf then
		return λ
	elseif A = 'I' then
		return n
	else
		return λ
	end
end

function h ( ⟨ A , B ⟩ , n ) begin
	if A = λ or (A ∉ alf and (A[0] = λ or A[1] = λ)) or ( B ∉ alf and |B| > 1 and B[0] = λ) then
		return λ
	elseif A ∈ alf then
		if B ∈ alf and n = ':' then
			return ':'
		elseif B ∉ alf and n ∈ alf then
			return n
		else
			return λ
		end
	else
		if n = ':' then
			return λ
		elseif n = ( '0' ‥ '4' ) then
			return '$'
		elseif n = A[0] then
			return A[1]
		elseif n = A[1] then
			return A[0]
		elseif n ∉ A and n = '#' then
			return B[0]
		elseif n ∉ A and n ≠ B[0] and B[1][0] = 1 then
			return backToDown(n)
		elseif n ∉ A and n ≠ B[0] and B[1][0] = 2 then
			return toDown(n)
		else
			return n
		end
	end
end

function g ( s ) begin
	return λ
end

function backToDown( n ) begin
	var r : Character
	r := (((n-'a'-1)%26) +32) +'a'
	return r
end

function toDown( n ) begin
	var r : Character
	r := ((n-'a') +32) +'a'
	return r
end



